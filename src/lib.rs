#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(non_camel_case_types)]

pub const BELA_MAJOR_VERSION: u32 = 1;
pub const BELA_MINOR_VERSION: u32 = 2;
pub const BELA_BUGFIX_VERSION: u32 = 0;
pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_ISO_10646__: u32 = 201505;
pub const __STDC_NO_THREADS__: u32 = 1;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 23;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __WORDSIZE: u32 = 32;
pub const _BITS_WCHAR_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -2147483648;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 2147483647;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 4294967295;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const INTPTR_MIN: i32 = -2147483648;
pub const INTPTR_MAX: u32 = 2147483647;
pub const UINTPTR_MAX: u32 = 4294967295;
pub const PTRDIFF_MIN: i32 = -2147483648;
pub const PTRDIFF_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: u32 = 4294967295;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const _UNISTD_H: u32 = 1;
pub const _POSIX_VERSION: u32 = 200809;
pub const __POSIX2_THIS_VERSION: u32 = 200809;
pub const _POSIX2_VERSION: u32 = 200809;
pub const _POSIX2_C_VERSION: u32 = 200809;
pub const _POSIX2_C_BIND: u32 = 200809;
pub const _POSIX2_C_DEV: u32 = 200809;
pub const _POSIX2_SW_DEV: u32 = 200809;
pub const _POSIX2_LOCALEDEF: u32 = 200809;
pub const _XOPEN_VERSION: u32 = 700;
pub const _XOPEN_XCU_VERSION: u32 = 4;
pub const _XOPEN_XPG2: u32 = 1;
pub const _XOPEN_XPG3: u32 = 1;
pub const _XOPEN_XPG4: u32 = 1;
pub const _XOPEN_UNIX: u32 = 1;
pub const _XOPEN_CRYPT: u32 = 1;
pub const _XOPEN_ENH_I18N: u32 = 1;
pub const _XOPEN_LEGACY: u32 = 1;
pub const _BITS_POSIX_OPT_H: u32 = 1;
pub const _POSIX_JOB_CONTROL: u32 = 1;
pub const _POSIX_SAVED_IDS: u32 = 1;
pub const _POSIX_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_SYNCHRONIZED_IO: u32 = 200809;
pub const _POSIX_FSYNC: u32 = 200809;
pub const _POSIX_MAPPED_FILES: u32 = 200809;
pub const _POSIX_MEMLOCK: u32 = 200809;
pub const _POSIX_MEMLOCK_RANGE: u32 = 200809;
pub const _POSIX_MEMORY_PROTECTION: u32 = 200809;
pub const _POSIX_CHOWN_RESTRICTED: u32 = 0;
pub const _POSIX_VDISABLE: u8 = 0u8;
pub const _POSIX_NO_TRUNC: u32 = 1;
pub const _XOPEN_REALTIME: u32 = 1;
pub const _XOPEN_REALTIME_THREADS: u32 = 1;
pub const _XOPEN_SHM: u32 = 1;
pub const _POSIX_THREADS: u32 = 200809;
pub const _POSIX_REENTRANT_FUNCTIONS: u32 = 1;
pub const _POSIX_THREAD_SAFE_FUNCTIONS: u32 = 200809;
pub const _POSIX_THREAD_PRIORITY_SCHEDULING: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKSIZE: u32 = 200809;
pub const _POSIX_THREAD_ATTR_STACKADDR: u32 = 200809;
pub const _POSIX_THREAD_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_PRIO_PROTECT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_INHERIT: u32 = 200809;
pub const _POSIX_THREAD_ROBUST_PRIO_PROTECT: i32 = -1;
pub const _POSIX_SEMAPHORES: u32 = 200809;
pub const _POSIX_REALTIME_SIGNALS: u32 = 200809;
pub const _POSIX_ASYNCHRONOUS_IO: u32 = 200809;
pub const _POSIX_ASYNC_IO: u32 = 1;
pub const _LFS_ASYNCHRONOUS_IO: u32 = 1;
pub const _POSIX_PRIORITIZED_IO: u32 = 200809;
pub const _LFS64_ASYNCHRONOUS_IO: u32 = 1;
pub const _LFS_LARGEFILE: u32 = 1;
pub const _LFS64_LARGEFILE: u32 = 1;
pub const _LFS64_STDIO: u32 = 1;
pub const _POSIX_SHARED_MEMORY_OBJECTS: u32 = 200809;
pub const _POSIX_CPUTIME: u32 = 0;
pub const _POSIX_THREAD_CPUTIME: u32 = 0;
pub const _POSIX_REGEXP: u32 = 1;
pub const _POSIX_READER_WRITER_LOCKS: u32 = 200809;
pub const _POSIX_SHELL: u32 = 1;
pub const _POSIX_TIMEOUTS: u32 = 200809;
pub const _POSIX_SPIN_LOCKS: u32 = 200809;
pub const _POSIX_SPAWN: u32 = 200809;
pub const _POSIX_TIMERS: u32 = 200809;
pub const _POSIX_BARRIERS: u32 = 200809;
pub const _POSIX_MESSAGE_PASSING: u32 = 200809;
pub const _POSIX_THREAD_PROCESS_SHARED: u32 = 200809;
pub const _POSIX_MONOTONIC_CLOCK: u32 = 0;
pub const _POSIX_CLOCK_SELECTION: u32 = 200809;
pub const _POSIX_ADVISORY_INFO: u32 = 200809;
pub const _POSIX_IPV6: u32 = 200809;
pub const _POSIX_RAW_SOCKETS: u32 = 200809;
pub const _POSIX2_CHAR_TERM: u32 = 200809;
pub const _POSIX_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_THREAD_SPORADIC_SERVER: i32 = -1;
pub const _POSIX_TRACE: i32 = -1;
pub const _POSIX_TRACE_EVENT_FILTER: i32 = -1;
pub const _POSIX_TRACE_INHERIT: i32 = -1;
pub const _POSIX_TRACE_LOG: i32 = -1;
pub const _POSIX_TYPED_MEMORY_OBJECTS: i32 = -1;
pub const _POSIX_V7_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V6_ILP32_OFFBIG: u32 = 1;
pub const _XBS5_ILP32_OFFBIG: u32 = 1;
pub const _POSIX_V7_ILP32_OFF32: u32 = 1;
pub const _POSIX_V6_ILP32_OFF32: u32 = 1;
pub const _XBS5_ILP32_OFF32: u32 = 1;
pub const __ILP32_OFF32_CFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFF32_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __ILP32_OFFBIG_CFLAGS: &'static [u8; 48usize] =
    b"-m32 -D_LARGEFILE_SOURCE -D_FILE_OFFSET_BITS=64\0";
pub const __ILP32_OFFBIG_LDFLAGS: &'static [u8; 5usize] = b"-m32\0";
pub const __LP64_OFF64_CFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const __LP64_OFF64_LDFLAGS: &'static [u8; 5usize] = b"-m64\0";
pub const STDIN_FILENO: u32 = 0;
pub const STDOUT_FILENO: u32 = 1;
pub const STDERR_FILENO: u32 = 2;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const R_OK: u32 = 4;
pub const W_OK: u32 = 2;
pub const X_OK: u32 = 1;
pub const F_OK: u32 = 0;
pub const SEEK_SET: u32 = 0;
pub const SEEK_CUR: u32 = 1;
pub const SEEK_END: u32 = 2;
pub const L_SET: u32 = 0;
pub const L_INCR: u32 = 1;
pub const L_XTND: u32 = 2;
pub const F_ULOCK: u32 = 0;
pub const F_LOCK: u32 = 1;
pub const F_TLOCK: u32 = 2;
pub const F_TEST: u32 = 3;
pub const true_: u32 = 1;
pub const false_: u32 = 0;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _STDIO_H: u32 = 1;
pub const __FILE_defined: u32 = 1;
pub const ____FILE_defined: u32 = 1;
pub const _G_config_h: u32 = 1;
pub const ____mbstate_t_defined: u32 = 1;
pub const _G_HAVE_MMAP: u32 = 1;
pub const _G_HAVE_MREMAP: u32 = 1;
pub const _G_IO_IO_FILE_VERSION: u32 = 131073;
pub const _G_BUFSIZ: u32 = 8192;
pub const _IO_BUFSIZ: u32 = 8192;
pub const __GNUC_VA_LIST: u32 = 1;
pub const _IO_UNIFIED_JUMPTABLES: u32 = 1;
pub const EOF: i32 = -1;
pub const _IOS_INPUT: u32 = 1;
pub const _IOS_OUTPUT: u32 = 2;
pub const _IOS_ATEND: u32 = 4;
pub const _IOS_APPEND: u32 = 8;
pub const _IOS_TRUNC: u32 = 16;
pub const _IOS_NOCREATE: u32 = 32;
pub const _IOS_NOREPLACE: u32 = 64;
pub const _IOS_BIN: u32 = 128;
pub const _IO_MAGIC: u32 = 4222418944;
pub const _OLD_STDIO_MAGIC: u32 = 4206624768;
pub const _IO_MAGIC_MASK: u32 = 4294901760;
pub const _IO_USER_BUF: u32 = 1;
pub const _IO_UNBUFFERED: u32 = 2;
pub const _IO_NO_READS: u32 = 4;
pub const _IO_NO_WRITES: u32 = 8;
pub const _IO_EOF_SEEN: u32 = 16;
pub const _IO_ERR_SEEN: u32 = 32;
pub const _IO_DELETE_DONT_CLOSE: u32 = 64;
pub const _IO_LINKED: u32 = 128;
pub const _IO_IN_BACKUP: u32 = 256;
pub const _IO_LINE_BUF: u32 = 512;
pub const _IO_TIED_PUT_GET: u32 = 1024;
pub const _IO_CURRENTLY_PUTTING: u32 = 2048;
pub const _IO_IS_APPENDING: u32 = 4096;
pub const _IO_IS_FILEBUF: u32 = 8192;
pub const _IO_BAD_SEEN: u32 = 16384;
pub const _IO_USER_LOCK: u32 = 32768;
pub const _IO_FLAGS2_MMAP: u32 = 1;
pub const _IO_FLAGS2_NOTCANCEL: u32 = 2;
pub const _IO_FLAGS2_USER_WBUF: u32 = 8;
pub const _IO_SKIPWS: u32 = 1;
pub const _IO_LEFT: u32 = 2;
pub const _IO_RIGHT: u32 = 4;
pub const _IO_INTERNAL: u32 = 8;
pub const _IO_DEC: u32 = 16;
pub const _IO_OCT: u32 = 32;
pub const _IO_HEX: u32 = 64;
pub const _IO_SHOWBASE: u32 = 128;
pub const _IO_SHOWPOINT: u32 = 256;
pub const _IO_UPPERCASE: u32 = 512;
pub const _IO_SHOWPOS: u32 = 1024;
pub const _IO_SCIENTIFIC: u32 = 2048;
pub const _IO_FIXED: u32 = 4096;
pub const _IO_UNITBUF: u32 = 8192;
pub const _IO_STDIO: u32 = 16384;
pub const _IO_DONT_CLOSE: u32 = 32768;
pub const _IO_BOOLALPHA: u32 = 65536;
pub const _IOFBF: u32 = 0;
pub const _IOLBF: u32 = 1;
pub const _IONBF: u32 = 2;
pub const BUFSIZ: u32 = 8192;
pub const P_tmpdir: &'static [u8; 5usize] = b"/tmp\0";
pub const L_tmpnam: u32 = 20;
pub const TMP_MAX: u32 = 238328;
pub const FILENAME_MAX: u32 = 4096;
pub const L_ctermid: u32 = 9;
pub const FOPEN_MAX: u32 = 16;
pub const SYSFS_GPIO_DIR: &'static [u8; 16usize] = b"/sys/class/gpio\0";
pub const SYSFS_LED_DIR: &'static [u8; 16usize] = b"/sys/class/leds\0";
pub const POLL_TIMEOUT: u32 = 3000;
pub const MAX_BUF: u32 = 128;
pub const CODEC_I2C_ADDRESS: u32 = 24;
pub const MAX_PRU_FILENAME_LENGTH: u32 = 256;
pub const MAX_SERVERNAME_LENGTH: u32 = 256;
pub const BELA_AUDIO_PRIORITY: u32 = 95;
pub const DEFAULT_DAC_LEVEL: f64 = 0.0;
pub const DEFAULT_ADC_LEVEL: f64 = -6.0;
pub const DEFAULT_PGA_GAIN: u32 = 16;
pub const DEFAULT_HP_LEVEL: f64 = -6.0;
pub const BELA_FLAG_INTERLEAVED: u32 = 1;
pub const BELA_FLAG_ANALOG_OUTPUTS_PERSIST: u32 = 2;
pub const BELA_FLAG_DETECT_UNDERRUNS: u32 = 4;
pub const INPUT: u32 = 0;
pub const OUTPUT: u32 = 1;
pub type int_least8_t = ::std::os::raw::c_schar;
pub type int_least16_t = ::std::os::raw::c_short;
pub type int_least32_t = ::std::os::raw::c_int;
pub type int_least64_t = ::std::os::raw::c_longlong;
pub type uint_least8_t = ::std::os::raw::c_uchar;
pub type uint_least16_t = ::std::os::raw::c_ushort;
pub type uint_least32_t = ::std::os::raw::c_uint;
pub type uint_least64_t = ::std::os::raw::c_ulonglong;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_int;
pub type int_fast32_t = ::std::os::raw::c_int;
pub type int_fast64_t = ::std::os::raw::c_longlong;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_uint;
pub type uint_fast32_t = ::std::os::raw::c_uint;
pub type uint_fast64_t = ::std::os::raw::c_ulonglong;
pub type intmax_t = ::std::os::raw::c_longlong;
pub type uintmax_t = ::std::os::raw::c_ulonglong;
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __quad_t = ::std::os::raw::c_longlong;
pub type __u_quad_t = ::std::os::raw::c_ulonglong;
pub type __dev_t = __u_quad_t;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = __u_quad_t;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_uint;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = __quad_t;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[test]
fn bindgen_test_layout___fsid_t() {
    assert_eq!(
        ::std::mem::size_of::<__fsid_t>(),
        8usize,
        concat!("Size of: ", stringify!(__fsid_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__fsid_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__fsid_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__fsid_t>())).__val as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__fsid_t),
            "::",
            stringify!(__val)
        )
    );
}
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = __u_quad_t;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = __quad_t;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = __u_quad_t;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = __u_quad_t;
pub type __fsword_t = ::std::os::raw::c_int;
pub type __ssize_t = ::std::os::raw::c_int;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __qaddr_t = *mut __quad_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_int;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type gid_t = __gid_t;
pub type uid_t = __uid_t;
pub type off_t = __off_t;
pub type useconds_t = __useconds_t;
pub type pid_t = __pid_t;
pub type socklen_t = __socklen_t;
extern "C" {
    pub fn access(
        __name: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn faccessat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __type: ::std::os::raw::c_int,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lseek(
        __fd: ::std::os::raw::c_int,
        __offset: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> __off_t;
}
extern "C" {
    pub fn close(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn read(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
    ) -> isize;
}
extern "C" {
    pub fn write(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
    ) -> isize;
}
extern "C" {
    pub fn pread(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_void,
        __nbytes: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pwrite(
        __fd: ::std::os::raw::c_int,
        __buf: *const ::std::os::raw::c_void,
        __n: usize,
        __offset: __off_t,
    ) -> isize;
}
extern "C" {
    pub fn pipe(__pipedes: *mut ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn alarm(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn sleep(__seconds: ::std::os::raw::c_uint) -> ::std::os::raw::c_uint;
}
extern "C" {
    pub fn ualarm(__value: __useconds_t, __interval: __useconds_t) -> __useconds_t;
}
extern "C" {
    pub fn usleep(__useconds: __useconds_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn pause() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchown(
        __fd: ::std::os::raw::c_int,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn lchown(
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchownat(
        __fd: ::std::os::raw::c_int,
        __file: *const ::std::os::raw::c_char,
        __owner: __uid_t,
        __group: __gid_t,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fchdir(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getcwd(__buf: *mut ::std::os::raw::c_char, __size: usize)
        -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getwd(__buf: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn dup(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dup2(__fd: ::std::os::raw::c_int, __fd2: ::std::os::raw::c_int)
        -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__environ"]
    pub static mut __environ: *mut *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn execve(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
        __envp: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fexecve(
        __fd: ::std::os::raw::c_int,
        __argv: *const *const ::std::os::raw::c_char,
        __envp: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execv(
        __path: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execle(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execl(
        __path: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execvp(
        __file: *const ::std::os::raw::c_char,
        __argv: *const *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn execlp(
        __file: *const ::std::os::raw::c_char,
        __arg: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn nice(__inc: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _exit(__status: ::std::os::raw::c_int);
}
pub const _PC_LINK_MAX: _bindgen_ty_1 = 0;
pub const _PC_MAX_CANON: _bindgen_ty_1 = 1;
pub const _PC_MAX_INPUT: _bindgen_ty_1 = 2;
pub const _PC_NAME_MAX: _bindgen_ty_1 = 3;
pub const _PC_PATH_MAX: _bindgen_ty_1 = 4;
pub const _PC_PIPE_BUF: _bindgen_ty_1 = 5;
pub const _PC_CHOWN_RESTRICTED: _bindgen_ty_1 = 6;
pub const _PC_NO_TRUNC: _bindgen_ty_1 = 7;
pub const _PC_VDISABLE: _bindgen_ty_1 = 8;
pub const _PC_SYNC_IO: _bindgen_ty_1 = 9;
pub const _PC_ASYNC_IO: _bindgen_ty_1 = 10;
pub const _PC_PRIO_IO: _bindgen_ty_1 = 11;
pub const _PC_SOCK_MAXBUF: _bindgen_ty_1 = 12;
pub const _PC_FILESIZEBITS: _bindgen_ty_1 = 13;
pub const _PC_REC_INCR_XFER_SIZE: _bindgen_ty_1 = 14;
pub const _PC_REC_MAX_XFER_SIZE: _bindgen_ty_1 = 15;
pub const _PC_REC_MIN_XFER_SIZE: _bindgen_ty_1 = 16;
pub const _PC_REC_XFER_ALIGN: _bindgen_ty_1 = 17;
pub const _PC_ALLOC_SIZE_MIN: _bindgen_ty_1 = 18;
pub const _PC_SYMLINK_MAX: _bindgen_ty_1 = 19;
pub const _PC_2_SYMLINKS: _bindgen_ty_1 = 20;
pub type _bindgen_ty_1 = u32;
pub const _SC_ARG_MAX: _bindgen_ty_2 = 0;
pub const _SC_CHILD_MAX: _bindgen_ty_2 = 1;
pub const _SC_CLK_TCK: _bindgen_ty_2 = 2;
pub const _SC_NGROUPS_MAX: _bindgen_ty_2 = 3;
pub const _SC_OPEN_MAX: _bindgen_ty_2 = 4;
pub const _SC_STREAM_MAX: _bindgen_ty_2 = 5;
pub const _SC_TZNAME_MAX: _bindgen_ty_2 = 6;
pub const _SC_JOB_CONTROL: _bindgen_ty_2 = 7;
pub const _SC_SAVED_IDS: _bindgen_ty_2 = 8;
pub const _SC_REALTIME_SIGNALS: _bindgen_ty_2 = 9;
pub const _SC_PRIORITY_SCHEDULING: _bindgen_ty_2 = 10;
pub const _SC_TIMERS: _bindgen_ty_2 = 11;
pub const _SC_ASYNCHRONOUS_IO: _bindgen_ty_2 = 12;
pub const _SC_PRIORITIZED_IO: _bindgen_ty_2 = 13;
pub const _SC_SYNCHRONIZED_IO: _bindgen_ty_2 = 14;
pub const _SC_FSYNC: _bindgen_ty_2 = 15;
pub const _SC_MAPPED_FILES: _bindgen_ty_2 = 16;
pub const _SC_MEMLOCK: _bindgen_ty_2 = 17;
pub const _SC_MEMLOCK_RANGE: _bindgen_ty_2 = 18;
pub const _SC_MEMORY_PROTECTION: _bindgen_ty_2 = 19;
pub const _SC_MESSAGE_PASSING: _bindgen_ty_2 = 20;
pub const _SC_SEMAPHORES: _bindgen_ty_2 = 21;
pub const _SC_SHARED_MEMORY_OBJECTS: _bindgen_ty_2 = 22;
pub const _SC_AIO_LISTIO_MAX: _bindgen_ty_2 = 23;
pub const _SC_AIO_MAX: _bindgen_ty_2 = 24;
pub const _SC_AIO_PRIO_DELTA_MAX: _bindgen_ty_2 = 25;
pub const _SC_DELAYTIMER_MAX: _bindgen_ty_2 = 26;
pub const _SC_MQ_OPEN_MAX: _bindgen_ty_2 = 27;
pub const _SC_MQ_PRIO_MAX: _bindgen_ty_2 = 28;
pub const _SC_VERSION: _bindgen_ty_2 = 29;
pub const _SC_PAGESIZE: _bindgen_ty_2 = 30;
pub const _SC_RTSIG_MAX: _bindgen_ty_2 = 31;
pub const _SC_SEM_NSEMS_MAX: _bindgen_ty_2 = 32;
pub const _SC_SEM_VALUE_MAX: _bindgen_ty_2 = 33;
pub const _SC_SIGQUEUE_MAX: _bindgen_ty_2 = 34;
pub const _SC_TIMER_MAX: _bindgen_ty_2 = 35;
pub const _SC_BC_BASE_MAX: _bindgen_ty_2 = 36;
pub const _SC_BC_DIM_MAX: _bindgen_ty_2 = 37;
pub const _SC_BC_SCALE_MAX: _bindgen_ty_2 = 38;
pub const _SC_BC_STRING_MAX: _bindgen_ty_2 = 39;
pub const _SC_COLL_WEIGHTS_MAX: _bindgen_ty_2 = 40;
pub const _SC_EQUIV_CLASS_MAX: _bindgen_ty_2 = 41;
pub const _SC_EXPR_NEST_MAX: _bindgen_ty_2 = 42;
pub const _SC_LINE_MAX: _bindgen_ty_2 = 43;
pub const _SC_RE_DUP_MAX: _bindgen_ty_2 = 44;
pub const _SC_CHARCLASS_NAME_MAX: _bindgen_ty_2 = 45;
pub const _SC_2_VERSION: _bindgen_ty_2 = 46;
pub const _SC_2_C_BIND: _bindgen_ty_2 = 47;
pub const _SC_2_C_DEV: _bindgen_ty_2 = 48;
pub const _SC_2_FORT_DEV: _bindgen_ty_2 = 49;
pub const _SC_2_FORT_RUN: _bindgen_ty_2 = 50;
pub const _SC_2_SW_DEV: _bindgen_ty_2 = 51;
pub const _SC_2_LOCALEDEF: _bindgen_ty_2 = 52;
pub const _SC_PII: _bindgen_ty_2 = 53;
pub const _SC_PII_XTI: _bindgen_ty_2 = 54;
pub const _SC_PII_SOCKET: _bindgen_ty_2 = 55;
pub const _SC_PII_INTERNET: _bindgen_ty_2 = 56;
pub const _SC_PII_OSI: _bindgen_ty_2 = 57;
pub const _SC_POLL: _bindgen_ty_2 = 58;
pub const _SC_SELECT: _bindgen_ty_2 = 59;
pub const _SC_UIO_MAXIOV: _bindgen_ty_2 = 60;
pub const _SC_IOV_MAX: _bindgen_ty_2 = 60;
pub const _SC_PII_INTERNET_STREAM: _bindgen_ty_2 = 61;
pub const _SC_PII_INTERNET_DGRAM: _bindgen_ty_2 = 62;
pub const _SC_PII_OSI_COTS: _bindgen_ty_2 = 63;
pub const _SC_PII_OSI_CLTS: _bindgen_ty_2 = 64;
pub const _SC_PII_OSI_M: _bindgen_ty_2 = 65;
pub const _SC_T_IOV_MAX: _bindgen_ty_2 = 66;
pub const _SC_THREADS: _bindgen_ty_2 = 67;
pub const _SC_THREAD_SAFE_FUNCTIONS: _bindgen_ty_2 = 68;
pub const _SC_GETGR_R_SIZE_MAX: _bindgen_ty_2 = 69;
pub const _SC_GETPW_R_SIZE_MAX: _bindgen_ty_2 = 70;
pub const _SC_LOGIN_NAME_MAX: _bindgen_ty_2 = 71;
pub const _SC_TTY_NAME_MAX: _bindgen_ty_2 = 72;
pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: _bindgen_ty_2 = 73;
pub const _SC_THREAD_KEYS_MAX: _bindgen_ty_2 = 74;
pub const _SC_THREAD_STACK_MIN: _bindgen_ty_2 = 75;
pub const _SC_THREAD_THREADS_MAX: _bindgen_ty_2 = 76;
pub const _SC_THREAD_ATTR_STACKADDR: _bindgen_ty_2 = 77;
pub const _SC_THREAD_ATTR_STACKSIZE: _bindgen_ty_2 = 78;
pub const _SC_THREAD_PRIORITY_SCHEDULING: _bindgen_ty_2 = 79;
pub const _SC_THREAD_PRIO_INHERIT: _bindgen_ty_2 = 80;
pub const _SC_THREAD_PRIO_PROTECT: _bindgen_ty_2 = 81;
pub const _SC_THREAD_PROCESS_SHARED: _bindgen_ty_2 = 82;
pub const _SC_NPROCESSORS_CONF: _bindgen_ty_2 = 83;
pub const _SC_NPROCESSORS_ONLN: _bindgen_ty_2 = 84;
pub const _SC_PHYS_PAGES: _bindgen_ty_2 = 85;
pub const _SC_AVPHYS_PAGES: _bindgen_ty_2 = 86;
pub const _SC_ATEXIT_MAX: _bindgen_ty_2 = 87;
pub const _SC_PASS_MAX: _bindgen_ty_2 = 88;
pub const _SC_XOPEN_VERSION: _bindgen_ty_2 = 89;
pub const _SC_XOPEN_XCU_VERSION: _bindgen_ty_2 = 90;
pub const _SC_XOPEN_UNIX: _bindgen_ty_2 = 91;
pub const _SC_XOPEN_CRYPT: _bindgen_ty_2 = 92;
pub const _SC_XOPEN_ENH_I18N: _bindgen_ty_2 = 93;
pub const _SC_XOPEN_SHM: _bindgen_ty_2 = 94;
pub const _SC_2_CHAR_TERM: _bindgen_ty_2 = 95;
pub const _SC_2_C_VERSION: _bindgen_ty_2 = 96;
pub const _SC_2_UPE: _bindgen_ty_2 = 97;
pub const _SC_XOPEN_XPG2: _bindgen_ty_2 = 98;
pub const _SC_XOPEN_XPG3: _bindgen_ty_2 = 99;
pub const _SC_XOPEN_XPG4: _bindgen_ty_2 = 100;
pub const _SC_CHAR_BIT: _bindgen_ty_2 = 101;
pub const _SC_CHAR_MAX: _bindgen_ty_2 = 102;
pub const _SC_CHAR_MIN: _bindgen_ty_2 = 103;
pub const _SC_INT_MAX: _bindgen_ty_2 = 104;
pub const _SC_INT_MIN: _bindgen_ty_2 = 105;
pub const _SC_LONG_BIT: _bindgen_ty_2 = 106;
pub const _SC_WORD_BIT: _bindgen_ty_2 = 107;
pub const _SC_MB_LEN_MAX: _bindgen_ty_2 = 108;
pub const _SC_NZERO: _bindgen_ty_2 = 109;
pub const _SC_SSIZE_MAX: _bindgen_ty_2 = 110;
pub const _SC_SCHAR_MAX: _bindgen_ty_2 = 111;
pub const _SC_SCHAR_MIN: _bindgen_ty_2 = 112;
pub const _SC_SHRT_MAX: _bindgen_ty_2 = 113;
pub const _SC_SHRT_MIN: _bindgen_ty_2 = 114;
pub const _SC_UCHAR_MAX: _bindgen_ty_2 = 115;
pub const _SC_UINT_MAX: _bindgen_ty_2 = 116;
pub const _SC_ULONG_MAX: _bindgen_ty_2 = 117;
pub const _SC_USHRT_MAX: _bindgen_ty_2 = 118;
pub const _SC_NL_ARGMAX: _bindgen_ty_2 = 119;
pub const _SC_NL_LANGMAX: _bindgen_ty_2 = 120;
pub const _SC_NL_MSGMAX: _bindgen_ty_2 = 121;
pub const _SC_NL_NMAX: _bindgen_ty_2 = 122;
pub const _SC_NL_SETMAX: _bindgen_ty_2 = 123;
pub const _SC_NL_TEXTMAX: _bindgen_ty_2 = 124;
pub const _SC_XBS5_ILP32_OFF32: _bindgen_ty_2 = 125;
pub const _SC_XBS5_ILP32_OFFBIG: _bindgen_ty_2 = 126;
pub const _SC_XBS5_LP64_OFF64: _bindgen_ty_2 = 127;
pub const _SC_XBS5_LPBIG_OFFBIG: _bindgen_ty_2 = 128;
pub const _SC_XOPEN_LEGACY: _bindgen_ty_2 = 129;
pub const _SC_XOPEN_REALTIME: _bindgen_ty_2 = 130;
pub const _SC_XOPEN_REALTIME_THREADS: _bindgen_ty_2 = 131;
pub const _SC_ADVISORY_INFO: _bindgen_ty_2 = 132;
pub const _SC_BARRIERS: _bindgen_ty_2 = 133;
pub const _SC_BASE: _bindgen_ty_2 = 134;
pub const _SC_C_LANG_SUPPORT: _bindgen_ty_2 = 135;
pub const _SC_C_LANG_SUPPORT_R: _bindgen_ty_2 = 136;
pub const _SC_CLOCK_SELECTION: _bindgen_ty_2 = 137;
pub const _SC_CPUTIME: _bindgen_ty_2 = 138;
pub const _SC_THREAD_CPUTIME: _bindgen_ty_2 = 139;
pub const _SC_DEVICE_IO: _bindgen_ty_2 = 140;
pub const _SC_DEVICE_SPECIFIC: _bindgen_ty_2 = 141;
pub const _SC_DEVICE_SPECIFIC_R: _bindgen_ty_2 = 142;
pub const _SC_FD_MGMT: _bindgen_ty_2 = 143;
pub const _SC_FIFO: _bindgen_ty_2 = 144;
pub const _SC_PIPE: _bindgen_ty_2 = 145;
pub const _SC_FILE_ATTRIBUTES: _bindgen_ty_2 = 146;
pub const _SC_FILE_LOCKING: _bindgen_ty_2 = 147;
pub const _SC_FILE_SYSTEM: _bindgen_ty_2 = 148;
pub const _SC_MONOTONIC_CLOCK: _bindgen_ty_2 = 149;
pub const _SC_MULTI_PROCESS: _bindgen_ty_2 = 150;
pub const _SC_SINGLE_PROCESS: _bindgen_ty_2 = 151;
pub const _SC_NETWORKING: _bindgen_ty_2 = 152;
pub const _SC_READER_WRITER_LOCKS: _bindgen_ty_2 = 153;
pub const _SC_SPIN_LOCKS: _bindgen_ty_2 = 154;
pub const _SC_REGEXP: _bindgen_ty_2 = 155;
pub const _SC_REGEX_VERSION: _bindgen_ty_2 = 156;
pub const _SC_SHELL: _bindgen_ty_2 = 157;
pub const _SC_SIGNALS: _bindgen_ty_2 = 158;
pub const _SC_SPAWN: _bindgen_ty_2 = 159;
pub const _SC_SPORADIC_SERVER: _bindgen_ty_2 = 160;
pub const _SC_THREAD_SPORADIC_SERVER: _bindgen_ty_2 = 161;
pub const _SC_SYSTEM_DATABASE: _bindgen_ty_2 = 162;
pub const _SC_SYSTEM_DATABASE_R: _bindgen_ty_2 = 163;
pub const _SC_TIMEOUTS: _bindgen_ty_2 = 164;
pub const _SC_TYPED_MEMORY_OBJECTS: _bindgen_ty_2 = 165;
pub const _SC_USER_GROUPS: _bindgen_ty_2 = 166;
pub const _SC_USER_GROUPS_R: _bindgen_ty_2 = 167;
pub const _SC_2_PBS: _bindgen_ty_2 = 168;
pub const _SC_2_PBS_ACCOUNTING: _bindgen_ty_2 = 169;
pub const _SC_2_PBS_LOCATE: _bindgen_ty_2 = 170;
pub const _SC_2_PBS_MESSAGE: _bindgen_ty_2 = 171;
pub const _SC_2_PBS_TRACK: _bindgen_ty_2 = 172;
pub const _SC_SYMLOOP_MAX: _bindgen_ty_2 = 173;
pub const _SC_STREAMS: _bindgen_ty_2 = 174;
pub const _SC_2_PBS_CHECKPOINT: _bindgen_ty_2 = 175;
pub const _SC_V6_ILP32_OFF32: _bindgen_ty_2 = 176;
pub const _SC_V6_ILP32_OFFBIG: _bindgen_ty_2 = 177;
pub const _SC_V6_LP64_OFF64: _bindgen_ty_2 = 178;
pub const _SC_V6_LPBIG_OFFBIG: _bindgen_ty_2 = 179;
pub const _SC_HOST_NAME_MAX: _bindgen_ty_2 = 180;
pub const _SC_TRACE: _bindgen_ty_2 = 181;
pub const _SC_TRACE_EVENT_FILTER: _bindgen_ty_2 = 182;
pub const _SC_TRACE_INHERIT: _bindgen_ty_2 = 183;
pub const _SC_TRACE_LOG: _bindgen_ty_2 = 184;
pub const _SC_LEVEL1_ICACHE_SIZE: _bindgen_ty_2 = 185;
pub const _SC_LEVEL1_ICACHE_ASSOC: _bindgen_ty_2 = 186;
pub const _SC_LEVEL1_ICACHE_LINESIZE: _bindgen_ty_2 = 187;
pub const _SC_LEVEL1_DCACHE_SIZE: _bindgen_ty_2 = 188;
pub const _SC_LEVEL1_DCACHE_ASSOC: _bindgen_ty_2 = 189;
pub const _SC_LEVEL1_DCACHE_LINESIZE: _bindgen_ty_2 = 190;
pub const _SC_LEVEL2_CACHE_SIZE: _bindgen_ty_2 = 191;
pub const _SC_LEVEL2_CACHE_ASSOC: _bindgen_ty_2 = 192;
pub const _SC_LEVEL2_CACHE_LINESIZE: _bindgen_ty_2 = 193;
pub const _SC_LEVEL3_CACHE_SIZE: _bindgen_ty_2 = 194;
pub const _SC_LEVEL3_CACHE_ASSOC: _bindgen_ty_2 = 195;
pub const _SC_LEVEL3_CACHE_LINESIZE: _bindgen_ty_2 = 196;
pub const _SC_LEVEL4_CACHE_SIZE: _bindgen_ty_2 = 197;
pub const _SC_LEVEL4_CACHE_ASSOC: _bindgen_ty_2 = 198;
pub const _SC_LEVEL4_CACHE_LINESIZE: _bindgen_ty_2 = 199;
pub const _SC_IPV6: _bindgen_ty_2 = 235;
pub const _SC_RAW_SOCKETS: _bindgen_ty_2 = 236;
pub const _SC_V7_ILP32_OFF32: _bindgen_ty_2 = 237;
pub const _SC_V7_ILP32_OFFBIG: _bindgen_ty_2 = 238;
pub const _SC_V7_LP64_OFF64: _bindgen_ty_2 = 239;
pub const _SC_V7_LPBIG_OFFBIG: _bindgen_ty_2 = 240;
pub const _SC_SS_REPL_MAX: _bindgen_ty_2 = 241;
pub const _SC_TRACE_EVENT_NAME_MAX: _bindgen_ty_2 = 242;
pub const _SC_TRACE_NAME_MAX: _bindgen_ty_2 = 243;
pub const _SC_TRACE_SYS_MAX: _bindgen_ty_2 = 244;
pub const _SC_TRACE_USER_EVENT_MAX: _bindgen_ty_2 = 245;
pub const _SC_XOPEN_STREAMS: _bindgen_ty_2 = 246;
pub const _SC_THREAD_ROBUST_PRIO_INHERIT: _bindgen_ty_2 = 247;
pub const _SC_THREAD_ROBUST_PRIO_PROTECT: _bindgen_ty_2 = 248;
pub type _bindgen_ty_2 = u32;
pub const _CS_PATH: _bindgen_ty_3 = 0;
pub const _CS_V6_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 1;
pub const _CS_GNU_LIBC_VERSION: _bindgen_ty_3 = 2;
pub const _CS_GNU_LIBPTHREAD_VERSION: _bindgen_ty_3 = 3;
pub const _CS_V5_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 4;
pub const _CS_V7_WIDTH_RESTRICTED_ENVS: _bindgen_ty_3 = 5;
pub const _CS_LFS_CFLAGS: _bindgen_ty_3 = 1000;
pub const _CS_LFS_LDFLAGS: _bindgen_ty_3 = 1001;
pub const _CS_LFS_LIBS: _bindgen_ty_3 = 1002;
pub const _CS_LFS_LINTFLAGS: _bindgen_ty_3 = 1003;
pub const _CS_LFS64_CFLAGS: _bindgen_ty_3 = 1004;
pub const _CS_LFS64_LDFLAGS: _bindgen_ty_3 = 1005;
pub const _CS_LFS64_LIBS: _bindgen_ty_3 = 1006;
pub const _CS_LFS64_LINTFLAGS: _bindgen_ty_3 = 1007;
pub const _CS_XBS5_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1100;
pub const _CS_XBS5_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1101;
pub const _CS_XBS5_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1102;
pub const _CS_XBS5_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1103;
pub const _CS_XBS5_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1104;
pub const _CS_XBS5_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1105;
pub const _CS_XBS5_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1106;
pub const _CS_XBS5_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1107;
pub const _CS_XBS5_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1108;
pub const _CS_XBS5_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1109;
pub const _CS_XBS5_LP64_OFF64_LIBS: _bindgen_ty_3 = 1110;
pub const _CS_XBS5_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1111;
pub const _CS_XBS5_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1112;
pub const _CS_XBS5_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1113;
pub const _CS_XBS5_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1114;
pub const _CS_XBS5_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1115;
pub const _CS_POSIX_V6_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1116;
pub const _CS_POSIX_V6_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1117;
pub const _CS_POSIX_V6_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1118;
pub const _CS_POSIX_V6_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1119;
pub const _CS_POSIX_V6_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1120;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1121;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1122;
pub const _CS_POSIX_V6_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1123;
pub const _CS_POSIX_V6_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1124;
pub const _CS_POSIX_V6_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1125;
pub const _CS_POSIX_V6_LP64_OFF64_LIBS: _bindgen_ty_3 = 1126;
pub const _CS_POSIX_V6_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1127;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1128;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1129;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1130;
pub const _CS_POSIX_V6_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1131;
pub const _CS_POSIX_V7_ILP32_OFF32_CFLAGS: _bindgen_ty_3 = 1132;
pub const _CS_POSIX_V7_ILP32_OFF32_LDFLAGS: _bindgen_ty_3 = 1133;
pub const _CS_POSIX_V7_ILP32_OFF32_LIBS: _bindgen_ty_3 = 1134;
pub const _CS_POSIX_V7_ILP32_OFF32_LINTFLAGS: _bindgen_ty_3 = 1135;
pub const _CS_POSIX_V7_ILP32_OFFBIG_CFLAGS: _bindgen_ty_3 = 1136;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1137;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LIBS: _bindgen_ty_3 = 1138;
pub const _CS_POSIX_V7_ILP32_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1139;
pub const _CS_POSIX_V7_LP64_OFF64_CFLAGS: _bindgen_ty_3 = 1140;
pub const _CS_POSIX_V7_LP64_OFF64_LDFLAGS: _bindgen_ty_3 = 1141;
pub const _CS_POSIX_V7_LP64_OFF64_LIBS: _bindgen_ty_3 = 1142;
pub const _CS_POSIX_V7_LP64_OFF64_LINTFLAGS: _bindgen_ty_3 = 1143;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_CFLAGS: _bindgen_ty_3 = 1144;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LDFLAGS: _bindgen_ty_3 = 1145;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LIBS: _bindgen_ty_3 = 1146;
pub const _CS_POSIX_V7_LPBIG_OFFBIG_LINTFLAGS: _bindgen_ty_3 = 1147;
pub const _CS_V6_ENV: _bindgen_ty_3 = 1148;
pub const _CS_V7_ENV: _bindgen_ty_3 = 1149;
pub type _bindgen_ty_3 = u32;
extern "C" {
    pub fn pathconf(
        __path: *const ::std::os::raw::c_char,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn fpathconf(
        __fd: ::std::os::raw::c_int,
        __name: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sysconf(__name: ::std::os::raw::c_int) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn confstr(
        __name: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> usize;
}
extern "C" {
    pub fn getpid() -> __pid_t;
}
extern "C" {
    pub fn getppid() -> __pid_t;
}
extern "C" {
    pub fn getpgrp() -> __pid_t;
}
extern "C" {
    pub fn __getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getpgid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn setpgid(__pid: __pid_t, __pgid: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setpgrp() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setsid() -> __pid_t;
}
extern "C" {
    pub fn getsid(__pid: __pid_t) -> __pid_t;
}
extern "C" {
    pub fn getuid() -> __uid_t;
}
extern "C" {
    pub fn geteuid() -> __uid_t;
}
extern "C" {
    pub fn getgid() -> __gid_t;
}
extern "C" {
    pub fn getegid() -> __gid_t;
}
extern "C" {
    pub fn getgroups(__size: ::std::os::raw::c_int, __list: *mut __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setreuid(__ruid: __uid_t, __euid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn seteuid(__uid: __uid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setgid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setregid(__rgid: __gid_t, __egid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setegid(__gid: __gid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fork() -> __pid_t;
}
extern "C" {
    pub fn vfork() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyname(__fd: ::std::os::raw::c_int) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn ttyname_r(
        __fd: ::std::os::raw::c_int,
        __buf: *mut ::std::os::raw::c_char,
        __buflen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn isatty(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ttyslot() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn link(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn linkat(
        __fromfd: ::std::os::raw::c_int,
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
        __flags: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn symlink(
        __from: *const ::std::os::raw::c_char,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlink(
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn symlinkat(
        __from: *const ::std::os::raw::c_char,
        __tofd: ::std::os::raw::c_int,
        __to: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn readlinkat(
        __fd: ::std::os::raw::c_int,
        __path: *const ::std::os::raw::c_char,
        __buf: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> isize;
}
extern "C" {
    pub fn unlink(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn unlinkat(
        __fd: ::std::os::raw::c_int,
        __name: *const ::std::os::raw::c_char,
        __flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rmdir(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tcgetpgrp(__fd: ::std::os::raw::c_int) -> __pid_t;
}
extern "C" {
    pub fn tcsetpgrp(__fd: ::std::os::raw::c_int, __pgrp_id: __pid_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getlogin() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn getlogin_r(
        __name: *mut ::std::os::raw::c_char,
        __name_len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setlogin(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}optarg"]
    pub static mut optarg: *mut ::std::os::raw::c_char;
}
extern "C" {
    #[link_name = "\u{1}optind"]
    pub static mut optind: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}opterr"]
    pub static mut opterr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}optopt"]
    pub static mut optopt: ::std::os::raw::c_int;
}
extern "C" {
    pub fn getopt(
        ___argc: ::std::os::raw::c_int,
        ___argv: *const *const ::std::os::raw::c_char,
        __shortopts: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostname(__name: *mut ::std::os::raw::c_char, __len: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sethostid(__id: ::std::os::raw::c_long) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdomainname(
        __name: *mut ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setdomainname(
        __name: *const ::std::os::raw::c_char,
        __len: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vhangup() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn revoke(__file: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn profil(
        __sample_buffer: *mut ::std::os::raw::c_ushort,
        __size: usize,
        __offset: usize,
        __scale: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn acct(__name: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getusershell() -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn endusershell();
}
extern "C" {
    pub fn setusershell();
}
extern "C" {
    pub fn daemon(
        __nochdir: ::std::os::raw::c_int,
        __noclose: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn chroot(__path: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getpass(__prompt: *const ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fsync(__fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gethostid() -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn sync();
}
extern "C" {
    pub fn getpagesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getdtablesize() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn truncate(
        __file: *const ::std::os::raw::c_char,
        __length: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftruncate(__fd: ::std::os::raw::c_int, __length: __off_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn brk(__addr: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sbrk(__delta: isize) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn syscall(__sysno: ::std::os::raw::c_long, ...) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn lockf(
        __fd: ::std::os::raw::c_int,
        __cmd: ::std::os::raw::c_int,
        __len: __off_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fdatasync(__fildes: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
pub type FILE = _IO_FILE;
pub type __FILE = _IO_FILE;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __mbstate_t {
    pub __count: ::std::os::raw::c_int,
    pub __value: __mbstate_t__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t__bindgen_ty_1 {
    pub __wch: ::std::os::raw::c_uint,
    pub __wchb: [::std::os::raw::c_char; 4usize],
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout___mbstate_t__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wch as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wch)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__mbstate_t__bindgen_ty_1>())).__wchb as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t__bindgen_ty_1),
            "::",
            stringify!(__wchb)
        )
    );
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__value as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__value)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos_t {
    pub __pos: __off_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos_t>(),
        12usize,
        concat!("Size of: ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_G_fpos_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos_t>())).__state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos_t),
            "::",
            stringify!(__state)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _G_fpos64_t {
    pub __pos: __off64_t,
    pub __state: __mbstate_t,
}
#[test]
fn bindgen_test_layout__G_fpos64_t() {
    assert_eq!(
        ::std::mem::size_of::<_G_fpos64_t>(),
        16usize,
        concat!("Size of: ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_G_fpos64_t>(),
        4usize,
        concat!("Alignment of ", stringify!(_G_fpos64_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__pos as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__pos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_G_fpos64_t>())).__state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_G_fpos64_t),
            "::",
            stringify!(__state)
        )
    );
}
pub type va_list = __builtin_va_list;
pub type __gnuc_va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_jump_t {
    _unused: [u8; 0],
}
pub type _IO_lock_t = ::std::os::raw::c_void;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_marker {
    pub _next: *mut _IO_marker,
    pub _sbuf: *mut _IO_FILE,
    pub _pos: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout__IO_marker() {
    assert_eq!(
        ::std::mem::size_of::<_IO_marker>(),
        12usize,
        concat!("Size of: ", stringify!(_IO_marker))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_marker>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_marker))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._next as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._sbuf as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_sbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_marker>()))._pos as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_marker),
            "::",
            stringify!(_pos)
        )
    );
}
pub const __codecvt_result___codecvt_ok: __codecvt_result = 0;
pub const __codecvt_result___codecvt_partial: __codecvt_result = 1;
pub const __codecvt_result___codecvt_error: __codecvt_result = 2;
pub const __codecvt_result___codecvt_noconv: __codecvt_result = 3;
pub type __codecvt_result = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _IO_FILE {
    pub _flags: ::std::os::raw::c_int,
    pub _IO_read_ptr: *mut ::std::os::raw::c_char,
    pub _IO_read_end: *mut ::std::os::raw::c_char,
    pub _IO_read_base: *mut ::std::os::raw::c_char,
    pub _IO_write_base: *mut ::std::os::raw::c_char,
    pub _IO_write_ptr: *mut ::std::os::raw::c_char,
    pub _IO_write_end: *mut ::std::os::raw::c_char,
    pub _IO_buf_base: *mut ::std::os::raw::c_char,
    pub _IO_buf_end: *mut ::std::os::raw::c_char,
    pub _IO_save_base: *mut ::std::os::raw::c_char,
    pub _IO_backup_base: *mut ::std::os::raw::c_char,
    pub _IO_save_end: *mut ::std::os::raw::c_char,
    pub _markers: *mut _IO_marker,
    pub _chain: *mut _IO_FILE,
    pub _fileno: ::std::os::raw::c_int,
    pub _flags2: ::std::os::raw::c_int,
    pub _old_offset: __off_t,
    pub _cur_column: ::std::os::raw::c_ushort,
    pub _vtable_offset: ::std::os::raw::c_schar,
    pub _shortbuf: [::std::os::raw::c_char; 1usize],
    pub _lock: *mut _IO_lock_t,
    pub _offset: __off64_t,
    pub __pad1: *mut ::std::os::raw::c_void,
    pub __pad2: *mut ::std::os::raw::c_void,
    pub __pad3: *mut ::std::os::raw::c_void,
    pub __pad4: *mut ::std::os::raw::c_void,
    pub __pad5: usize,
    pub _mode: ::std::os::raw::c_int,
    pub _unused2: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__IO_FILE() {
    assert_eq!(
        ::std::mem::size_of::<_IO_FILE>(),
        148usize,
        concat!("Size of: ", stringify!(_IO_FILE))
    );
    assert_eq!(
        ::std::mem::align_of::<_IO_FILE>(),
        4usize,
        concat!("Alignment of ", stringify!(_IO_FILE))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_ptr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_end as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_read_base as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_read_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_base as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_ptr as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_ptr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_write_end as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_write_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_base as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_buf_end as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_buf_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_base as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_backup_base as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_backup_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._IO_save_end as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_IO_save_end)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._markers as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_markers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._chain as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_chain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._fileno as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_fileno)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._flags2 as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_flags2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._old_offset as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_old_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._cur_column as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_cur_column)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._vtable_offset as *const _ as usize },
        70usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_vtable_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._shortbuf as *const _ as usize },
        71usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_shortbuf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._lock as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._offset as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad1 as *const _ as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad2 as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad3 as *const _ as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad4 as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad4)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>())).__pad5 as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(__pad5)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._mode as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_mode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_IO_FILE>()))._unused2 as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(_IO_FILE),
            "::",
            stringify!(_unused2)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE_plus {
    _unused: [u8; 0],
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdin_"]
    pub static mut _IO_2_1_stdin_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stdout_"]
    pub static mut _IO_2_1_stdout_: _IO_FILE_plus;
}
extern "C" {
    #[link_name = "\u{1}_IO_2_1_stderr_"]
    pub static mut _IO_2_1_stderr_: _IO_FILE_plus;
}
pub type __io_read_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *mut ::std::os::raw::c_char,
        __nbytes: usize,
    ) -> __ssize_t,
>;
pub type __io_write_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __buf: *const ::std::os::raw::c_char,
        __n: usize,
    ) -> __ssize_t,
>;
pub type __io_seek_fn = ::std::option::Option<
    unsafe extern "C" fn(
        __cookie: *mut ::std::os::raw::c_void,
        __pos: *mut __off64_t,
        __w: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int,
>;
pub type __io_close_fn = ::std::option::Option<
    unsafe extern "C" fn(__cookie: *mut ::std::os::raw::c_void) -> ::std::os::raw::c_int,
>;
extern "C" {
    pub fn __underflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __uflow(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn __overflow(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_getc(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_putc(__c: ::std::os::raw::c_int, __fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_feof(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_ferror(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_peekc_locked(__fp: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_flockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_funlockfile(arg1: *mut _IO_FILE);
}
extern "C" {
    pub fn _IO_ftrylockfile(arg1: *mut _IO_FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfscanf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
        arg4: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_vfprintf(
        arg1: *mut _IO_FILE,
        arg2: *const ::std::os::raw::c_char,
        arg3: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn _IO_padn(arg1: *mut _IO_FILE, arg2: ::std::os::raw::c_int, arg3: __ssize_t)
        -> __ssize_t;
}
extern "C" {
    pub fn _IO_sgetn(arg1: *mut _IO_FILE, arg2: *mut ::std::os::raw::c_void, arg3: usize) -> usize;
}
extern "C" {
    pub fn _IO_seekoff(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
        arg4: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_seekpos(
        arg1: *mut _IO_FILE,
        arg2: __off64_t,
        arg3: ::std::os::raw::c_int,
    ) -> __off64_t;
}
extern "C" {
    pub fn _IO_free_backup_area(arg1: *mut _IO_FILE);
}
pub type fpos_t = _G_fpos_t;
extern "C" {
    #[link_name = "\u{1}stdin"]
    pub static mut stdin: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stdout"]
    pub static mut stdout: *mut _IO_FILE;
}
extern "C" {
    #[link_name = "\u{1}stderr"]
    pub static mut stderr: *mut _IO_FILE;
}
extern "C" {
    pub fn remove(__filename: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rename(
        __old: *const ::std::os::raw::c_char,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn renameat(
        __oldfd: ::std::os::raw::c_int,
        __old: *const ::std::os::raw::c_char,
        __newfd: ::std::os::raw::c_int,
        __new: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn tmpfile() -> *mut FILE;
}
extern "C" {
    pub fn tmpnam(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tmpnam_r(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn tempnam(
        __dir: *const ::std::os::raw::c_char,
        __pfx: *const ::std::os::raw::c_char,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn fclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fflush_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn freopen(
        __filename: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
        __stream: *mut FILE,
    ) -> *mut FILE;
}
extern "C" {
    pub fn fdopen(__fd: ::std::os::raw::c_int, __modes: *const ::std::os::raw::c_char)
        -> *mut FILE;
}
extern "C" {
    pub fn fmemopen(
        __s: *mut ::std::os::raw::c_void,
        __len: usize,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn open_memstream(
        __bufloc: *mut *mut ::std::os::raw::c_char,
        __sizeloc: *mut usize,
    ) -> *mut FILE;
}
extern "C" {
    pub fn setbuf(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char);
}
extern "C" {
    pub fn setvbuf(
        __stream: *mut FILE,
        __buf: *mut ::std::os::raw::c_char,
        __modes: ::std::os::raw::c_int,
        __n: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn setbuffer(__stream: *mut FILE, __buf: *mut ::std::os::raw::c_char, __size: usize);
}
extern "C" {
    pub fn setlinebuf(__stream: *mut FILE);
}
extern "C" {
    pub fn fprintf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn printf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfprintf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vprintf(
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsprintf(
        __s: *mut ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn snprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsnprintf(
        __s: *mut ::std::os::raw::c_char,
        __maxlen: usize,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vdprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn dprintf(
        __fd: ::std::os::raw::c_int,
        __fmt: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fscanf(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn scanf(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn sscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_fscanf"]
    pub fn fscanf1(
        __stream: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_scanf"]
    pub fn scanf1(__format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_sscanf"]
    pub fn sscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfscanf(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vscanf(
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vsscanf(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vfscanf"]
    pub fn vfscanf1(
        __s: *mut FILE,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vscanf"]
    pub fn vscanf1(
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}__isoc99_vsscanf"]
    pub fn vsscanf1(
        __s: *const ::std::os::raw::c_char,
        __format: *const ::std::os::raw::c_char,
        __arg: __gnuc_va_list,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getchar_unlocked() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetc_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fputc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE)
        -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putc_unlocked(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putchar_unlocked(__c: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn getw(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn putw(__w: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgets(
        __s: *mut ::std::os::raw::c_char,
        __n: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn __getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getdelim(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __delimiter: ::std::os::raw::c_int,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn getline(
        __lineptr: *mut *mut ::std::os::raw::c_char,
        __n: *mut usize,
        __stream: *mut FILE,
    ) -> __ssize_t;
}
extern "C" {
    pub fn fputs(__s: *const ::std::os::raw::c_char, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn puts(__s: *const ::std::os::raw::c_char) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetc(__c: ::std::os::raw::c_int, __stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fread(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __s: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fread_unlocked(
        __ptr: *mut ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fwrite_unlocked(
        __ptr: *const ::std::os::raw::c_void,
        __size: usize,
        __n: usize,
        __stream: *mut FILE,
    ) -> usize;
}
extern "C" {
    pub fn fseek(
        __stream: *mut FILE,
        __off: ::std::os::raw::c_long,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftell(__stream: *mut FILE) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn rewind(__stream: *mut FILE);
}
extern "C" {
    pub fn fseeko(
        __stream: *mut FILE,
        __off: __off_t,
        __whence: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ftello(__stream: *mut FILE) -> __off_t;
}
extern "C" {
    pub fn fgetpos(__stream: *mut FILE, __pos: *mut fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fsetpos(__stream: *mut FILE, __pos: *const fpos_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr(__stream: *mut FILE);
}
extern "C" {
    pub fn feof(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn clearerr_unlocked(__stream: *mut FILE);
}
extern "C" {
    pub fn feof_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ferror_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn perror(__s: *const ::std::os::raw::c_char);
}
extern "C" {
    #[link_name = "\u{1}sys_nerr"]
    pub static mut sys_nerr: ::std::os::raw::c_int;
}
extern "C" {
    #[link_name = "\u{1}sys_errlist"]
    pub static mut sys_errlist: [*const ::std::os::raw::c_char; 0usize];
}
extern "C" {
    pub fn fileno(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fileno_unlocked(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn popen(
        __command: *const ::std::os::raw::c_char,
        __modes: *const ::std::os::raw::c_char,
    ) -> *mut FILE;
}
extern "C" {
    pub fn pclose(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ctermid(__s: *mut ::std::os::raw::c_char) -> *mut ::std::os::raw::c_char;
}
extern "C" {
    pub fn flockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn ftrylockfile(__stream: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn funlockfile(__stream: *mut FILE);
}
extern "C" {
    pub fn rt_printf(format: *const ::std::os::raw::c_char, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_fprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ...
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_vprintf(format: *const ::std::os::raw::c_char, ap: va_list) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rt_vfprintf(
        stream: *mut FILE,
        format: *const ::std::os::raw::c_char,
        ap: va_list,
    ) -> ::std::os::raw::c_int;
}
pub const BelaHw_BelaHw_NoHw: BelaHw = -1;
pub const BelaHw_BelaHw_Bela: BelaHw = 0;
pub const BelaHw_BelaHw_BelaMini: BelaHw = 1;
pub const BelaHw_BelaHw_Salt: BelaHw = 2;
pub const BelaHw_BelaHw_CtagFace: BelaHw = 3;
pub const BelaHw_BelaHw_CtagBeast: BelaHw = 4;
pub const BelaHw_BelaHw_CtagFaceBela: BelaHw = 5;
pub const BelaHw_BelaHw_CtagBeastBela: BelaHw = 6;
pub type BelaHw = i32;
pub const PIN_DIRECTION_INPUT_PIN: PIN_DIRECTION = 0;
pub const PIN_DIRECTION_OUTPUT_PIN: PIN_DIRECTION = 1;
pub type PIN_DIRECTION = u32;
pub const PIN_VALUE_LOW: PIN_VALUE = 0;
pub const PIN_VALUE_HIGH: PIN_VALUE = 1;
pub type PIN_VALUE = u32;
extern "C" {
    /// gpio_functions
    pub fn gpio_setup(
        gpio: ::std::os::raw::c_uint,
        out_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_export(gpio: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_unexport(gpio: ::std::os::raw::c_uint) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_set_dir(
        gpio: ::std::os::raw::c_uint,
        out_flag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_set_value(
        gpio: ::std::os::raw::c_uint,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_get_value(
        gpio: ::std::os::raw::c_uint,
        value: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_set_edge(
        gpio: ::std::os::raw::c_uint,
        edge: *mut ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_fd_open(
        gpio: ::std::os::raw::c_uint,
        writeFlag: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_fd_close(fd: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_write(
        fd: ::std::os::raw::c_int,
        value: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_read(
        fd: ::std::os::raw::c_int,
        value: *mut ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn gpio_dismiss(
        fd: ::std::os::raw::c_int,
        gpio: ::std::os::raw::c_uint,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn led_set_trigger(
        lednum: ::std::os::raw::c_uint,
        trigger: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct option {
    _unused: [u8; 0],
}
/// \ingroup render
/// \brief Structure holding audio and sensor settings and pointers to I/O data buffers.
///
/// This structure is passed to setup(), render() and cleanup() and provides access to
/// Bela's I/O functionality. It is initialised in Bela_initAudio() based on the contents
/// of the BelaInitSettings structure.
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct BelaContext {
    /// \brief Buffer holding audio input samples
    /// ///
    /// /// This buffer allows Bela's audio input data to be read during render().
    /// /// By default the buffer contains data from all the audio input channels arranged
    /// /// in interleaved format.
    /// ///
    /// /// Every time render() runs this buffer is filled with a block of new audio samples.
    /// /// The block is made up of frames, individual slices of time consisting of one sample
    /// /// taken from each audio input channel simultaneously. The number of frames per
    /// /// block is given by context->audioFrames, and the number of audio input channels
    /// /// by context->audioInChannels. The length of this buffer is the product of these
    /// /// two values.
    /// ///
    /// /// The buffer can be accessed manually with standard array notation or more
    /// /// conveniently using the audioRead() utility.
    /// ///
    /// /// \b Note: this element is available in render() only.
    pub audioIn: *const f32,
    /// \brief Buffer holding audio output samples
    /// ///
    /// /// This buffer allows Bela's audio output data to be written during render().
    /// /// By default the buffer must contain data from all the audio output channels
    /// /// arranged in interleaved format.
    /// ///
    /// /// Every time render() runs it is the job of the developer to fill this buffer with
    /// /// a block of new audio samples, structured in the same way as context->audioIn.
    /// ///
    /// /// The buffer can be accessed manually with standard array notation or more
    /// /// conveniently using the audioWrite() utility.
    /// ///
    /// /// \b Note: this element is available in render() only.
    pub audioOut: *const f32,
    /// \brief Buffer holding analog input samples
    /// ///
    /// /// This buffer allows Bela's analog input data to be read during render().
    /// /// By default the buffer contains data from all the analog input channels arranged
    /// /// in interleaved format.
    /// ///
    /// /// Every time render() runs this buffer is filled with a block of new analog samples.
    /// /// The block is made up of frames, individual slices of time consisting of one sample
    /// /// taken from each analog input channel simultaneously. The number of frames per
    /// /// block is given by context->analogFrames, and the number of analog input channels
    /// /// by context->analogInChannels. The length of this buffer is the product of these
    /// /// two values.
    /// ///
    /// /// The buffer can be accessed manually with standard array notation or more
    /// /// conveniently using the analogRead() utility.
    /// ///
    /// /// \b Note: this element is available in render() only.
    pub analogIn: *const f32,
    /// \brief Buffer holding analog output samples
    /// ///
    /// /// This buffer allows Bela's analog output data to be written during render().
    /// /// By default the buffer must contain data from all the analog output channels
    /// /// arranged in interleaved format.
    /// ///
    /// /// Every time render() runs it is the job of the developer to fill this buffer with
    /// /// a block of new analog samples, structured in the same way as context->analogIn.
    /// ///
    /// /// The buffer can be accessed manually with standard array notation or more
    /// /// conveniently using the analogWrite() utility.
    /// ///
    /// /// \b Note: this element is available in render() only.
    pub analogOut: *const f32,
    /// \brief Buffer holding digital input/output samples
    /// ///
    /// /// This buffer allows Bela's digital GPIO data to be read and written during render().
    /// ///
    /// /// The buffer can be accessed manually with standard array notation or somewhat more
    /// /// conveniently using the digitalRead() and digitalWrite() utilities.
    /// ///
    /// /// \b Note: this element is available in render() only.
    pub digital: *const u32,
    /// \brief The number of audio frames per block
    /// ///
    /// /// Every time render() runs context->audioIn is filled with a block of new audio
    /// /// samples. The block is made up of frames, individual slices of time consisting of
    /// /// one sample taken from each audio input channel simultaneously.
    /// ///
    /// /// This value determines the number of audio frames in each block and can be adjusted
    /// /// in the IDE settings tab (or via the command line arguments) from 2 to 128,
    /// /// defaulting to 16.
    /// ///
    /// /// This value also determines how often render() is called, and reducing it decreases
    /// /// audio latency at the cost of increased CPU consumption.
    pub audioFrames: u32,
    /// \brief The number of audio input channels
    pub audioInChannels: u32,
    /// \brief The number of audio output channels
    pub audioOutChannels: u32,
    /// \brief The audio sample rate in Hz (currently always 44100.0)
    pub audioSampleRate: f32,
    /// \brief The number of analog frames per block
    /// ///
    /// /// Every time render() runs context->analogIn is filled with a block of new analog
    /// /// samples. The block is made up of frames, individual slices of time consisting of
    /// /// one sample taken from each analog input channel simultaneously.
    /// ///
    /// /// This value determines the number of analog frames in each block. It cannot be
    /// /// set directly as it is dependant on the number of audio frames per block
    /// /// (context->audioFrames) and the analog sample rate (context->analogSampleRate).
    /// ///
    /// /// This value will be 0 if analog I/O is disabled.
    pub analogFrames: u32,
    /// \brief The number of analog input channels
    /// ///
    /// /// This will be 0 if analog I/O is disabled.
    pub analogInChannels: u32,
    /// \brief The number of analog output channels
    /// ///
    /// /// This will be 0 if analog I/O is disabled.
    pub analogOutChannels: u32,
    /// \brief Analog sample rate in Hz
    /// ///
    /// /// This value determines the rate at which each analog input is sampled, and is
    /// /// directly related to the number of analog channels available. It can be adjusted
    /// /// in the IDE settings tab (or via the command line arguments) to 22050, 44100
    /// /// or 88200, allowing 8, 4, or 2 analog channels respectively. By default, all 8
    /// /// channels are sampled at 22050Hz.
    /// ///
    /// /// If analog I/O is disabled, this value is 0.
    pub analogSampleRate: f32,
    /// Number of digital frames per period
    pub digitalFrames: u32,
    /// \brief Number of digital channels
    /// ///
    /// /// Currently this will always be 16, unless digital I/O is disabled, in which case it will be 0.
    pub digitalChannels: u32,
    /// Digital sample rate in Hz (currently always 44100.0)
    pub digitalSampleRate: f32,
    /// \brief Number of elapsed audio frames since the start of rendering.
    /// ///
    /// /// This holds the total number of audio frames as of the beginning of the current block. To
    /// /// find the current number of analog or digital frames elapsed, multiply by the ratio of the
    /// /// sample rates (e.g. half the number of analog frames will have elapsed if the analog sample
    /// /// rate is 22050).
    pub audioFramesElapsed: u64,
    /// \brief Number of multiplexer channels for each analog input.
    /// ///
    /// /// This will be 2, 4 or 8 if the multiplexer capelet is enabled, otherwise it will be 1.
    /// /// 2, 4 and 8 correspond to 16, 32 and 64 analog inputs, respectively.
    pub multiplexerChannels: u32,
    /// \brief Multiplexer channel corresponding to the first analog frame.
    /// ///
    /// /// This indicates the multiplexer setting corresponding to the first analog frame in the
    /// /// buffer.
    pub multiplexerStartingChannel: u32,
    /// \brief Buffer which holds multiplexed analog inputs, when multiplexer capelet is enabled.
    /// ///
    /// /// Because the analog in buffer size may be smaller than a complete cycle of the multiplexer
    /// /// capelet, this buffer will always be big enough to hold at least one complete cycle of all
    /// /// channels. It will be null if the multiplexer capelet is not enabled.
    pub multiplexerAnalogIn: *const f32,
    /// \brief Flags for whether audio expander is enabled on given analog channels.
    /// ///
    /// /// Bits 0-15, when set, indicate audio expander enabled on the analog inputs. Bits 16-31
    /// /// indicate audio expander enabled on the analog outputs.
    pub audioExpanderEnabled: u32,
    /// \brief Other audio/sensor settings
    /// ///
    /// /// Binary combination of flags including:
    /// ///
    /// /// BELA_FLAG_INTERLEAVED: indicates the audio and analog buffers are interleaved
    /// ///
    /// /// BELA_FLAG_ANALOG_OUTPUTS_PERSIST: indicates that writes to the analog outputs will
    /// /// persist for future frames. If not set, writes affect one frame only.
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_BelaContext() {
    assert_eq!(
        ::std::mem::size_of::<BelaContext>(),
        92usize,
        concat!("Size of: ", stringify!(BelaContext))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaContext>(),
        4usize,
        concat!("Alignment of ", stringify!(BelaContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioIn as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioIn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioOut as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).analogIn as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogIn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).analogOut as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogOut)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).digital as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digital)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioFrames as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioInChannels as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioInChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioOutChannels as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioOutChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioSampleRate as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).analogFrames as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).analogInChannels as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogInChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).analogOutChannels as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogOutChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).analogSampleRate as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(analogSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).digitalFrames as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digitalFrames)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).digitalChannels as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digitalChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).digitalSampleRate as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(digitalSampleRate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).audioFramesElapsed as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioFramesElapsed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).multiplexerChannels as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(multiplexerChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaContext>())).multiplexerStartingChannel as *const _ as usize
        },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(multiplexerStartingChannel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).multiplexerAnalogIn as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(multiplexerAnalogIn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaContext>())).audioExpanderEnabled as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(audioExpanderEnabled)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaContext>())).flags as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaContext),
            "::",
            stringify!(flags)
        )
    );
}
/// \ingroup control
/// \brief Structure containing initialisation parameters for the real-time
/// audio control system.
///
/// This structure is initialised using Bela_defaultSettings(). Its contents
/// are used up through the point of calling
/// Bela_initAudio() at which point it is no longer needed.
#[repr(C)]
#[derive(Copy, Clone)]
pub struct BelaInitSettings {
    /// \brief Number of (analog) frames per period.
    /// ///
    /// /// Number of audio frames depends on relative sample rates of the two. By default,
    /// /// audio is twice the sample rate, so has twice the period size.
    pub periodSize: ::std::os::raw::c_int,
    /// Whether to use the analog input and output
    pub useAnalog: ::std::os::raw::c_int,
    /// Whether to use the 16 programmable GPIOs
    pub useDigital: ::std::os::raw::c_int,
    /// How many audio input channels
    pub numAudioInChannels: ::std::os::raw::c_int,
    /// How many audio out channels
    pub numAudioOutChannels: ::std::os::raw::c_int,
    /// How many analog input channels
    pub numAnalogInChannels: ::std::os::raw::c_int,
    /// How many analog output channels
    pub numAnalogOutChannels: ::std::os::raw::c_int,
    /// How many channels for the GPIOs
    pub numDigitalChannels: ::std::os::raw::c_int,
    /// Whether to begin with the speakers muted
    pub beginMuted: ::std::os::raw::c_int,
    /// Level for the audio DAC output
    pub dacLevel: f32,
    /// Level for the audio ADC input
    pub adcLevel: f32,
    /// Gains for the PGA, left and right channels
    pub pgaGain: [f32; 2usize],
    /// Level for the headphone output
    pub headphoneLevel: f32,
    /// How many channels to use on the multiplexer capelet, if enabled
    pub numMuxChannels: ::std::os::raw::c_int,
    /// Which audio expander settings to use on the input
    pub audioExpanderInputs: ::std::os::raw::c_uint,
    /// Which audio expander settings to use on the input
    pub audioExpanderOutputs: ::std::os::raw::c_uint,
    /// Which PRU (0 or 1) the code should run on
    pub pruNumber: ::std::os::raw::c_int,
    /// The external .bin file to load. If empty will use PRU code from pru_rtaudio_bin.h
    pub pruFilename: [::std::os::raw::c_char; 256usize],
    /// Whether to detect and log underruns
    pub detectUnderruns: ::std::os::raw::c_int,
    /// Whether to use verbose logging
    pub verbose: ::std::os::raw::c_int,
    /// Whether to use the blinking LED to indicate Bela is running
    pub enableLED: ::std::os::raw::c_int,
    /// Whether to monitor the Bela cape button on P9.27 / GPIO3[19]
    pub enableCapeButtonMonitoring: ::std::os::raw::c_int,
    /// Whether to use high-performance mode: gives more CPU to
    /// /// the Bela task. The Linux part of the board and the IDE may
    /// /// freeze while the program is running. Use the button on the
    /// /// Bela cape to forcefully stop the running program
    pub highPerformanceMode: ::std::os::raw::c_int,
    /// Whether audio/analog data should be interleaved
    pub interleave: ::std::os::raw::c_int,
    /// \brief Whether analog outputs should persist to future frames.
    /// ///
    /// /// n.b. digital pins always persist, audio never does
    pub analogOutputsPersist: ::std::os::raw::c_int,
    /// \brief Whether the analog channels should be resampled to
    /// /// audio sampling rate.
    pub uniformSampleRate: ::std::os::raw::c_int,
    /// \brief The requested stack size for the audio thread. Defaults
    pub audioThreadStackSize: ::std::os::raw::c_uint,
    /// \brief The requested stack size for each AuxilaryTask. Defaults
    pub auxiliaryTaskStackSize: ::std::os::raw::c_uint,
    pub setup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void) -> bool,
    >,
    pub render: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void),
    >,
    pub cleanup: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut BelaContext, arg2: *mut ::std::os::raw::c_void),
    >,
    /// Where the codec can be found on the I2C bus
    pub codecI2CAddress: ::std::os::raw::c_int,
    /// Pin where amplifier mute can be found
    pub ampMutePin: ::std::os::raw::c_int,
    /// Port where the UDP server will listen
    pub receivePort: ::std::os::raw::c_int,
    /// Port where the UDP client will transmit
    pub transmitPort: ::std::os::raw::c_int,
    pub serverName: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_BelaInitSettings() {
    assert_eq!(
        ::std::mem::size_of::<BelaInitSettings>(),
        652usize,
        concat!("Size of: ", stringify!(BelaInitSettings))
    );
    assert_eq!(
        ::std::mem::align_of::<BelaInitSettings>(),
        4usize,
        concat!("Alignment of ", stringify!(BelaInitSettings))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).periodSize as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(periodSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).useAnalog as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(useAnalog)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).useDigital as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(useDigital)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).numAudioInChannels as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAudioInChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).numAudioOutChannels as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAudioOutChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).numAnalogInChannels as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAnalogInChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).numAnalogOutChannels as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numAnalogOutChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).numDigitalChannels as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numDigitalChannels)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).beginMuted as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(beginMuted)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).dacLevel as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(dacLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).adcLevel as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(adcLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).pgaGain as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(pgaGain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).headphoneLevel as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(headphoneLevel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).numMuxChannels as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(numMuxChannels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).audioExpanderInputs as *const _ as usize
        },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioExpanderInputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).audioExpanderOutputs as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioExpanderOutputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).pruNumber as *const _ as usize },
        68usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(pruNumber)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).pruFilename as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(pruFilename)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).detectUnderruns as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(detectUnderruns)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).verbose as *const _ as usize },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(verbose)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).enableLED as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(enableLED)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).enableCapeButtonMonitoring as *const _
                as usize
        },
        340usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(enableCapeButtonMonitoring)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).highPerformanceMode as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(highPerformanceMode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).interleave as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(interleave)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).analogOutputsPersist as *const _ as usize
        },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(analogOutputsPersist)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).uniformSampleRate as *const _ as usize
        },
        356usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(uniformSampleRate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).audioThreadStackSize as *const _ as usize
        },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(audioThreadStackSize)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).auxiliaryTaskStackSize as *const _ as usize
        },
        364usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(auxiliaryTaskStackSize)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).setup as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(setup)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).render as *const _ as usize },
        372usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(render)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).cleanup as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(cleanup)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<BelaInitSettings>())).codecI2CAddress as *const _ as usize
        },
        380usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(codecI2CAddress)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).ampMutePin as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(ampMutePin)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).receivePort as *const _ as usize },
        388usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(receivePort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).transmitPort as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(transmitPort)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<BelaInitSettings>())).serverName as *const _ as usize },
        396usize,
        concat!(
            "Offset of field: ",
            stringify!(BelaInitSettings),
            "::",
            stringify!(serverName)
        )
    );
}
/// \ingroup auxtask
///
/// Auxiliary task variable. Auxiliary tasks are created using createAuxiliaryTask() and
/// automatically cleaned up after cleanup() finishes.
pub type AuxiliaryTask = *mut ::std::os::raw::c_void;
extern "C" {
    #[link_name = "\u{1}gShouldStop"]
    pub static mut gShouldStop: ::std::os::raw::c_int;
}
extern "C" {
    /// \brief User-defined initialisation function which runs before audio rendering begins.
    ///
    /// This function runs once at the beginning of the program, after most of the system
    /// initialisation has begun but before audio rendering starts. Use it to prepare any
    /// memory or resources that will be needed in render().
    ///
    /// \param context Data structure holding information on sample rates, numbers of channels,
    /// frame sizes and other state. Note: the buffers for audio, analog and digital data will
    /// \b not yet be available to use. Do not attempt to read or write audio or sensor data
    /// in setup().
    /// \param userData An opaque pointer to an optional user-defined data structure. Whatever
    /// is passed as the second argument to Bela_initAudio() will appear here.
    ///
    /// \return true on success, or false if an error occurred. If no initialisation is
    /// required, setup() should return true.
    pub fn setup(context: *mut BelaContext, userData: *mut ::std::os::raw::c_void) -> bool;
}
extern "C" {
    /// \brief User-defined callback function to process audio and sensor data.
    ///
    /// This function is called regularly by the system every time there is a new block of
    /// audio and/or sensor data to process. Your code should process the requested samples
    /// of data, store the results within \c context, and return.
    ///
    /// \param context Data structure holding buffers for audio, analog and digital data. The
    /// structure also holds information on numbers of channels, frame sizes and sample rates,
    /// which are guaranteed to remain the same throughout the program and to match what was
    /// passed to setup().
    /// \param userData An opaque pointer to an optional user-defined data structure. Will
    /// be the same as the \c userData parameter passed to setup().
    pub fn render(context: *mut BelaContext, userData: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// \brief User-defined cleanup function which runs when the program finishes.
    ///
    /// This function is called by the system once after audio rendering has finished, before the
    /// program quits. Use it to release any memory allocated in setup() and to perform
    /// any other required cleanup. If no initialisation is performed in setup(), then
    /// this function will usually be empty.
    ///
    /// \param context Data structure holding information on sample rates, numbers of channels,
    /// frame sizes and other state. Note: the buffers for audio, analog and digital data will
    /// no longer be available to use. Do not attempt to read or write audio or sensor data
    /// in cleanup().
    /// \param userData An opaque pointer to an optional user-defined data structure. Will
    /// be the same as the \c userData parameter passed to setup() and render().
    pub fn cleanup(context: *mut BelaContext, userData: *mut ::std::os::raw::c_void);
}
extern "C" {
    /// \brief Initialise the data structure containing settings for Bela.
    ///
    /// This function should be called in main() before parsing any command-line arguments. It
    /// sets default values in the data structure which specifies the Bela settings, including
    /// frame sizes, numbers of channels, volume levels and other parameters.
    ///
    /// \param settings Structure holding initialisation data for Bela.
    pub fn Bela_defaultSettings(settings: *mut BelaInitSettings);
}
extern "C" {
    /// \brief Initialise the data structure containing settings for Bela.
    ///
    /// This function fwill be called by Bela_defaultSettings() after the settings have been
    /// initialied. It has weak linking so the user is free - but not forced to - define it.
    /// It can be used to override some of the default settings if the user code does not have
    /// access to the call to Bela_defaultSettings() (e.g.: because it is handled by the backend
    /// code).
    ///
    /// \param settings Structure holding initialisation data for Bela.
    pub fn Bela_userSettings(settings: *mut BelaInitSettings);
}
extern "C" {
    /// \brief Get long options from command line argument list, including Bela standard options
    ///
    /// This function should be used in main() to process command line options, in place of the
    /// standard library getopt_long(). Internally, it parses standard Bela command-line options,
    /// storing the results in the settings data structure. Any options which are not part of the
    /// Bela standard options will be returned, as they would normally be in getopt_long().
    ///
    /// \param argc Number of command line options, as passed to main().
    /// \param argv Array of command line options, as passed to main().
    /// \param customShortOptions List of short options to be parsed, analogous to getopt_long(). This
    /// list should not include any characters already parsed as part of the Bela standard options.
    /// \param customLongOptions List of long options to parsed, analogous to getopt_long(). This
    /// list should not include any long options already parsed as part of the Bela standard options.
    /// \param settings Data structure holding initialisation settings for Bela. Any standard options
    /// parsed will automatically update this data structure.
    ///
    /// \return Value of the next option parsed which is not a Bela standard option, or -1 when the
    /// argument list has been exhausted. Similar to the return value of getopt_long() except that Bela
    /// standard options are handled internally and not returned.
    pub fn Bela_getopt_long(
        argc: ::std::os::raw::c_int,
        argv: *mut *mut ::std::os::raw::c_char,
        customShortOptions: *const ::std::os::raw::c_char,
        customLongOptions: *const option,
        settings: *mut BelaInitSettings,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Print usage information for Bela standard options.
    ///
    /// This function should be called from your code wherever you wish to print usage information for the
    /// user. It will print usage information on Bela standard options, after which you can print usage
    /// information for your own custom options.
    pub fn Bela_usage();
}
extern "C" {
    /// \brief Get the version of Bela you are running.
    pub fn Bela_getVersion(
        major: *mut ::std::os::raw::c_int,
        minor: *mut ::std::os::raw::c_int,
        bugfix: *mut ::std::os::raw::c_int,
    );
}
extern "C" {
    /// \brief Set level of verbose (debugging) printing.
    ///
    /// \param level Verbosity level of the internal Bela system. 0 by default; higher values will
    /// print more information. Presently all positive numbers produce the same level of printing.
    pub fn Bela_setVerboseLevel(level: ::std::os::raw::c_int);
}
extern "C" {
    /// \brief Detect what hardware we are running on.
    pub fn Bela_detectHw() -> BelaHw;
}
extern "C" {
    /// \brief Initialise audio and sensor rendering environment.
    ///
    /// This function prepares audio rendering in Bela. It should be called from main() sometime
    /// after command line option parsing has finished. It will initialise the rendering system, which
    /// in the process will result in a call to the user-defined setup() function.
    ///
    /// \param settings Data structure holding system settings, including numbers of channels, frame sizes,
    /// volume levels and other information.
    /// \param userData An opaque pointer to a user-defined data structure which will be passed to
    /// setup(), render() and cleanup(). You can use this to pass custom information
    /// to the rendering functions, as an alternative to using global variables.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_initAudio(
        settings: *mut BelaInitSettings,
        userData: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Begin processing audio and sensor data.
    ///
    /// This function will start the Bela audio/sensor system. After this function is called, the
    /// system will make periodic calls to render() until Bela_stopAudio() is called.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_startAudio() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Begin processing audio and sensor data in the same thread as the caller.
    ///
    /// This function will start the Bela audio/sensor system. After this function is called, the
    /// system will make periodic calls to render() until Bela_stopAudio() is called.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_runInSameThread() -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Stop processing audio and sensor data.
    ///
    /// This function will stop the Bela audio/sensor system. After this function returns, no further
    /// calls to render() will be issued.
    pub fn Bela_stopAudio();
}
extern "C" {
    /// \brief Clean up resources from audio and sensor processing.
    ///
    /// This function should only be called after Bela_stopAudio(). It will release any
    /// internal resources for audio and sensor processing. In the process, it will call the
    /// user-defined cleanup() function.
    pub fn Bela_cleanupAudio();
}
extern "C" {
    /// \brief Set the level of the audio DAC.
    ///
    /// This function sets the level of all audio outputs (headphone, line, speaker). It does
    /// not affect the level of the (non-audio) analog outputs.
    ///
    /// \b Important: do not call this function from within render(), as it does not make
    /// any guarantees on real-time performance.
    ///
    /// \param decibels Level of the DAC output. Valid levels range from -63.5 (lowest) to
    /// 0 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded down.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_setDACLevel(decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the level of the audio ADC.
    ///
    /// This function sets the level of the audio input. It does not affect the level of the
    /// (non-audio) analog inputs.
    ///
    /// \b Important: do not call this function from within render(), as it does not make
    /// any guarantees on real-time performance.
    ///
    /// \param decibels Level of the ADC input. Valid levels range from -12 (lowest) to
    /// 0 (highest) in steps of 1.5dB. Levels between increments of 1.5 will be rounded down.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_setADCLevel(decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the gain of the audio preamplifier.
    ///
    /// This function sets the level of the Programmable Gain Amplifier(PGA), which
    /// amplifies the signal before the ADC.
    ///
    /// \b Important: do not call this function from within render(), as it does not make
    /// any guarantees on real-time performance.
    ///
    /// \param decibels Level of the PGA Valid levels range from 0 (lowest) to
    /// 59.5 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded.
    /// \param channel Specifies which channel to apply the gain to. Channel 0 is left,
    /// channel 1 is right
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_setPgaGain(decibels: f32, channel: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Set the level of the onboard headphone amplifier.
    ///
    /// This function sets the level of the headphone output only (3-pin connector on the Bela
    /// cape or the output jack on the BeagleBone Audio Cape). It does not affect the level of the
    /// speakers or the line out pads on the cape.
    ///
    /// \b Important: do not call this function from within render(), as it does not make
    /// any guarantees on real-time performance.
    ///
    /// \param decibels Level of the DAC output. Valid levels range from -63.5 (lowest) to
    /// 0 (highest) in steps of 0.5dB. Levels between increments of 0.5 will be rounded down.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_setHeadphoneLevel(decibels: f32) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Mute or unmute the onboard speaker amplifiers.
    ///
    /// This function mutes or unmutes the amplifiers on the Bela cape. Whether the speakers begin
    /// muted or unmuted depends on the BelaInitSettings structure passed to Bela_initAudio().
    ///
    /// \b Important: do not call this function from within render(), as it does not make
    /// any guarantees on real-time performance.
    ///
    /// \param mute 0 to enable the speakers, nonzero to mute the speakers.
    ///
    /// \return 0 on success, or nonzero if an error occurred.
    pub fn Bela_muteSpeakers(mute: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Create a new auxiliary task.
    ///
    /// This function creates a new auxiliary task which, when scheduled, runs the function specified
    /// in the first argument. Note that the task does not run until scheduleAuxiliaryTask() is called.
    /// Auxiliary tasks should be created in `setup()` and never in `render()` itself.
    ///
    /// The second argument specifies the real-time priority. Valid values are between 0
    /// and 99, and usually should be lower than \ref BELA_AUDIO_PRIORITY. Tasks with higher priority always
    /// preempt tasks with lower priority.
    ///
    /// \param callback Function which will be called each time the auxiliary task is scheduled, unless it is already running.
    /// \param priority Xenomai priority level at which the task should run.
    /// \param name Name for this task, which should be unique system-wide (no other running program should use this name).
    /// \param arg The argument passed to the callback function.
    pub fn Bela_createAuxiliaryTask(
        callback: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
        priority: ::std::os::raw::c_int,
        name: *const ::std::os::raw::c_char,
        arg: *mut ::std::os::raw::c_void,
    ) -> AuxiliaryTask;
}
extern "C" {
    /// \brief Run an auxiliary task which has previously been created.
    ///
    /// This function will schedule an auxiliary task to run.
    ///
    /// If the task is already running, calling this function has no effect.
    /// If the task is not running (e.g.: a previous invocation has returned), the \b callback function defined
    /// in Bela_createAuxiliaryTask() will be called and it will be passed the \b arg pointer as its only parameter.
    ///
    /// This function is typically called from render() to start a lower-priority task. The function
    /// will not run immediately, but only once any active higher priority tasks have finished.
    ///
    /// \param task Task to schedule for running.
    /// \return 0 if the task was successfully scheduled, a positive error number otherwise. The most frequent error will be EBUSY, if the task was still running as a consequence of a previous call.
    pub fn Bela_scheduleAuxiliaryTask(task: AuxiliaryTask) -> ::std::os::raw::c_int;
}
extern "C" {
    /// \brief Initialize an auxiliary task so that it can be scheduled.
    ///
    /// User normally do not need to call this function.
    ///
    /// This function will start an auxiliary task but will NOT schedule it.
    /// This means that the callback function associated with the task will NOT be executed.
    ///
    /// It will also set a flag in the associate InternalAuxiliaryTask to flag the
    /// task as "started", so that successive calls to the same function for a given AuxiliaryTask
    /// have no effect.
    /// The user should never be required to call this function directly, as it is called
    /// by Bela_scheduleAuxiliaryTask if needed (e.g.: if a task is scheduled in setup() )
    /// or immediately after starting the audio thread.
    ///
    /// \param task Task to start.
    pub fn Bela_startAuxiliaryTask(task: AuxiliaryTask) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Bela_startAllAuxiliaryTasks() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn Bela_stopAllAuxiliaryTasks();
}
extern "C" {
    pub fn Bela_deleteAllAuxiliaryTasks();
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
